# 完成内容
阅读并实践《Rust程序设计》书中16章以及rustling中的小部分练习
# 要点记录
## 16 无畏并发
- 所有权和类型系统是一系列解决**内存安全** 和 **并发问题**的强有力的工具！
## 16.1 进程
- 在当前上下文中，**运行时** 代表二进制文件中包含的由语言自身提供的代码。这些代码根据语言的不同可大可小，不过任何非汇编语言都会有一定数量的运行时代码。
- 绿色线程的 M:N 模型需要更大的语言运行时来管理这些线程。因此，Rust 标准库只提供了 1:1 线程模型实现。
- 使用join等待线程结束
    - 通过调用 handle 的 ``join`` 会阻塞当前线程直到 handle 所代表的线程结束。**阻塞**（Blocking） 线程意味着阻止该线程执行工作或退出。
- 线程与 move 闭包
    - ``move`` 闭包，经常与 ``thread::spawn`` 一起使用，因为它允许我们在一个线程中使用另一个线程的数据。
    ```rust
    fn main() {
        let v = vec![1, 2, 3];

        let handle = thread::spawn(|| { //改为 let handle = thread::spawn(move || {
            println!("Here's a vector: {:?}", v);
        });

        handle.join().unwrap();
    }
    ```
    - Rust 会 **推断** 如何捕获 ``v``，因为 ``println!`` 只需要 ``v`` 的引用，闭包尝试借用 ``v``。然而这有一个问题：Rust 不知道这个新建线程会执行多久，所以无法知晓 ``v`` 的引用是否一直有效。
    - 通过在闭包之前增加 ``move`` 关键字，我们强制闭包获取其使用的值的所有权，而不是任由 Rust 推断它应该借用值。
## 16.2 使用消息传递在线程间传送数据
- 一个日益流行的确保安全并发的方式是 **消息传递**（message passing），这里线程或 actor 通过发送包含数据的消息来相互沟通。
- Rust 中一个实现消息传递并发的主要工具是 **通道**（channel），Rust 标准库提供了其实现的编程概念。编程中的通道有两部分组成，一个发送者（transmitter）和一个接收者（receiver）。发送者位于上游位置，在这里可以将橡皮鸭放入河中，接收者则位于下游，橡皮鸭最终会漂流至此。代码中的一部分调用发送者的方法以及希望发送的数据，另一部分则检查接收端收到的消息。当发送者或接收者任一被丢弃时可以认为通道被 **关闭**（closed）了。