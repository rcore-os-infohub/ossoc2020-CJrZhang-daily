# 完成内容
阅读并实践《Rust程序设计》书中10-12章
# 要点记录
## 10.1 泛型数据类型
- 在使用泛型时注意要声明泛型。  
```rust
impl<T, U> Point<T, U> { //impl字段后声明泛型<T,U>
    fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> { //函数名后声明泛型<V,W>
        Point {
            x: self.x,
            y: other.y,
        }
    }
}
```
- Rust 通过在编译时进行泛型代码的**单态化**（monomorphization）来保证效率。
## 10.2 trait：定义共享的行为
- trait 类似于其他语言中的常被称为**接口**（interfaces）的功能。  
- 在类型上实现 trait 类似于实现与 trait 无关的方法。区别在于 impl 关键字之后，我们提供需要实现 trait 的名称，接着是 for 和需要实现 trait 的类型的名称。
```rust
impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}
```
- 实现 trait 时需要注意的一个限制是，只有**当 trait 或者要实现 trait 的类型位于 crate 的本地作用域时**，才能为该类型实现 trait。  
- **不能为外部类型实现外部 trait。** 例如，不能在 aggregator crate 中为 Vec<T> 实现 Display trait。这是因为 Display 和 Vec<T> 都定义于标准库中，它们并不位于 aggregator crate 本地作用域中。  
- 默认实现允许调用相同 trait 中的其他方法，哪怕这些方法没有默认实现。
- trait作为参数
    - ``impl Trait`` 语法糖作为参数类型
    - Trait bound
        - 可以通过``+``语法指定多个trait bound
        - 通过``where``从句简化trait bound
    - ``impl Trait`` 语法糖作为返回值类型（**只适用于返回单一类型的情况。**）
- 可以通过trait bound使用多个``impl``块有条件的实现方法
- 也可以对任何实现了特定 trait 的类型有条件地实现 trait。对任何满足特定 trait bound 的类型实现 trait 被称为 blanket implementations，他们被广泛的用于 Rust 标准库中。例如，标准库为任何实现了 ``Display`` trait 的类型实现了 ``ToString`` trait。
```rust
impl<T: Display> ToString for T {
    // --snip--
}
```
## 10.3 生命周期与引用有效性
- Rust 中的每一个引用都有其 生命周期（lifetime），也就是引用保持有效的作用域。
- Rust 编译器有一个 借用检查器（borrow checker），它比较作用域来确保所有的借用都是有效的。
- **生命周期注解描述了多个引用生命周期相互的关系，而不影响其生命周期。**
- 函数签名中的生命周期注释：
    ```rust
    #![allow(unused_variables)]
    fn main() {
    fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
        if x.len() > y.len() {
            x
        } else {
            y
        }
    }
    }
    ```
    当具体的引用被传递给 longest 时，被 ``'a`` 所替代的具体生命周期是 ``x`` 的作用域与 ``y`` 的作用域相重叠的那一部分。换一种说法就是泛型生命周期 ``'a`` 的具体生命周期等同于 ``x`` 和 ``y`` 的生命周期中较小的那一个。因为我们用相同的生命周期参数 ``'a`` 标注了返回的引用值，所以返回的引用值就能保证在 ``x`` 和 ``y`` 中较短的那个生命周期结束之前保持有效。
- 当从函数返回一个引用，返回值的生命周期参数需要与一个参数的生命周期参数相匹配。如果返回的引用 **没有** 指向任何一个参数，那么唯一的可能就是它指向一个函数内部创建的值，它将会是一个悬垂引用，因为它将会在函数结束时离开作用域。尝试考虑这个并不能编译的 ``longest`` 函数实现：
    ```rust
    fn longest<'a>(x: &str, y: &str) -> &'a str {
        let result = String::from("really long string");
        result.as_str()
    }
    ```
    出现的问题是 ``result`` 在 ``longest`` 函数的结尾将离开作用域并被清理，而我们尝试从函数返回一个 ``result`` 的引用。无法指定生命周期参数来改变悬垂引用，而且 Rust 也不允许我们创建一个悬垂引用。
- **生命周期语法是用于将函数的多个参数与其返回值的生命周期进行关联的。一旦他们形成了某种关联，Rust 就有了足够的信息来允许内存安全的操作并阻止会产生悬垂指针亦或是违反内存安全的行为。**
- 包含引用的结构体定义中的生命周期注释
- 生命周期省略
    - 被编码进 Rust 引用分析的模式被称为 **生命周期省略规则**（lifetime elision rules）。这并不是需要程序员遵守的规则；这些规则是一系列特定的场景，此时编译器会考虑，如果代码符合这些场景，就无需明确指定生命周期。函数或方法的参数的生命周期被称为 **输入生命周期**（input lifetimes），而返回值的生命周期被称为 **输出生命周期**（output lifetimes）。
        - 第一条规则是每一个是引用的参数都有它自己的生命周期参数。
        - 第二条规则是如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数。
        - 第三条规则是如果方法有多个输入生命周期参数并且其中一个参数是 ``&self`` 或 ``&mut self``，说明是个对象的方法(method)，那么所有输出生命周期参数被赋予 self 的生命周期。
    - 编译器采用三条规则来判断引用何时不需要明确的注解。如果编译器检查完这三条规则后仍然存在没有计算出生命周期的引用，编译器将会停止并生成错误。这些规则适用于 ``fn`` 定义，以及 ``impl`` 块。
- 静态生命周期 ``'static``，其生命周期能够存活于整个程序期间。
## 11.1
- 测试函数体通常执行如下三种操作：
    - 设置任何所需的数据或状态
    - 运行需要测试的代码
    - 断言其结果是我们所期望的
- ``assert_eq!`` 和 ``assert_ne!`` 宏在底层分别使用了 ``==`` 和 ``!=``。当断言失败时，这些宏会使用调试格式打印出其参数，这意味着被比较的值必需实现了 ``PartialEq`` 和 ``Debug`` trait。所有的基本类型和大部分标准库类型都实现了这些 trait。对于自定义的结构体和枚举，需要实现 ``PartialEq`` 才能断言他们的值是否相等。需要实现 ``Debug`` 才能在断言失败时打印他们的值。因为这两个 trait 都是派生 trait，如第五章示例 5-12 所提到的，通常可以直接在结构体或枚举上添加 ``#[derive(PartialEq, Debug)]`` 注解。
- 你也可以向 ``assert!``、``assert_eq!`` 和 ``assert_ne!`` 宏传递一个可选的失败信息参数，可以在测试失败时将自定义失败信息一同打印出来。任何在 ``assert!`` 的一个必需参数和 ``assert_eq!`` 和 ``assert_ne!`` 的两个必需参数之后指定的参数都会传递给 ``format!`` 宏，所以可以传递一个包含 ``{}`` 占位符的格式字符串和需要放入占位符的值。
- 为了使 ``should_panic`` 测试结果更精确，我们可以给 ``should_panic`` 属性增加一个可选的 ``expected`` 参数。
- 使用 ``Result<T, E>`` 编写测试，在测试通过时返回 ``Ok(())``，在测试失败时返回带有 ``String`` 的 ``Err``。
## 11.2
- 当运行多个测试时， Rust 默认使用线程来并行运行。因为测试是在同时运行的，你应该**确保测试不能相互依赖，或依赖任何共享的状态，包括依赖共享的环境**，比如当前工作目录或者环境变量。如果你不希望测试并行运行，或者想要更加精确的控制线程的数量，可以传递 ``--test-threads`` 参数和希望使用线程的数量给测试二进制文件。
- 默认情况下，当测试通过时，Rust 的测试库会**截获打印到标准输出的所有内容。**截获输出的行为可以通过 ``--nocapture`` 参数来禁用。
- 可以向 ``cargo test`` 传递任意测试的名称来只运行这个测试。
- 我们可以指定部分测试的名称，任何名称匹配这个名称的测试会被运行。例如，因为头两个测试的名称包含 ``add``，可以通过 ``cargo test add`` 来运行这两个测试。
- 有时一些特定的测试执行起来是非常耗费时间的，可以使用 ``ignore`` 属性来标记耗时的测试并排除他们。对于想要排除的测试，我们在 ``#[test]`` 之后增加了 ``#[ignore]`` 行。
# 11.3
- **单元测试**（unit tests）与 **集成测试**（integration tests）
- 单元测试与他们要测试的代码共同存放在位于 src 目录下相同的文件中。规范是在每个文件中创建包含测试函数的 ``tests`` 模块，并使用 ``cfg(test)`` 标注模块。
- 为了编写集成测试，需要在项目根目录创建一个 tests 目录，与 src 同级。Cargo 知道如何去寻找这个目录中的集成测试文件。接着可以随意在这个目录中创建任意多的测试文件，Cargo 会将每一个文件当作单独的 crate 来编译。
    - 与单元测试不同，我们需要在文件顶部添加 ``use adder``。这是因为每一个 tests 目录中的测试文件都是完全独立的 crate，所以需要在每一个文件中导入库。
    - 集成测试中的子模块：如果我们并不想要``common`` 出现在测试结果中显示 ``running 0 tests`` 。我们只是希望其能被其他多个集成测试文件中调用罢了。为了不让 common 出现在测试输出中，我们将创建 tests/common/mod.rs ，而不是创建 tests/common.rs 。这是一种 Rust 的命名规范，这样命名告诉 Rust 不要将 ``common`` 看作一个集成测试文件。将 ``setup`` 函数代码移动到 tests/common/mod.rs 并删除 tests/common.rs 文件之后，测试输出中将不会出现这一部分。tests 目录中的子目录不会被作为单独的 crate 编译或作为一个测试结果部分出现在测试输出中。一旦拥有了 tests/common/mod.rs，就可以将其作为模块以便在任何集成测试文件中使用。
    ```rust
    use adder;

    mod common;

    #[test]
    fn it_adds_two() {
        common::setup();
        assert_eq!(4, adder::add_two(2));
    }
    ```
- **如果项目是二进制 crate 并且只包含 src/main.rs 而没有 src/lib.rs，这样就不可能在 tests 目录创建集成测试并使用 ``extern crate`` 导入 src/main.rs 中定义的函数。只有库 crate 才会向其他 crate 暴露了可供调用和使用的函数；二进制 crate 只意在单独运行。**
## 12.3
- 手动实现 ``panic!`` 的使用非零错误码退出命令行工具的工作。非零的退出状态是一个告诉调用程序的进程我们的程序以错误状态退出的惯例信号。``process::exit`` 会立即停止程序并将传递给它的数字作为退出状态码。
- 使用 ``unwrap_or_else`` 可以进行一些自定义的非 ``panic!`` 的错误处理。当 ``Result`` 是 ``Ok`` 时，这个方法的行为类似于 ``unwrap``：它返回 ``Ok`` 内部封装的值。然而，当其值是 ``Err`` 时，该方法会调用一个 **闭包**（closure），也就是一个我们定义的作为参数传递给 ``unwrap_or_else`` 的匿名函数。``unwrap_or_else`` 会将 ``Err ``的内部值，传递给闭包中位于两道竖线间的参数 ``err``。闭包中的代码在其运行时可以使用这个 ``err`` 值。