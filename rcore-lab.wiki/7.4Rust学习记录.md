# 完成内容
阅读并实践《Rust程序设计》书中13-15章
# 要点记录
## 13.1 闭包：可以捕获环境的匿名函数
- Rust 的 **闭包**（closures）是可以保存进变量或作为参数传递给其他函数的匿名函数。可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算。不同于函数，**闭包允许捕获调用者作用域中的值。**
- 闭包不要求像 ``fn`` 函数那样在参数和返回值上注明类型。函数中需要类型注解是因为他们是暴露给用户的显式接口的一部分。严格的定义这些接口对于保证所有人都认同函数使用和返回值的类型来说是很重要的。但是闭包并不用于这样暴露在外的接口：他们储存在变量中并被使用，不用命名他们或暴露给库的用户调用。
- 几种有效的闭包定义方式：
```rust
fn  add_one_v1   (x: u32) -> u32 { x + 1 } //不是闭包是函数定义，其他三个为闭包定义
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
```
- 第一次使用 ``String`` 值调用 ``example_closure`` 时，编译器推断 ``x`` 和此闭包返回值的类型为 ``String``。接着这些类型被锁定进闭包 ``example_closure`` 中，如果尝试对同一闭包使用不同类型则会得到类型错误。
- 使用带有泛型和 ``Fn`` trait 的闭包
    - **建议回看整个例子，比较重要**
- 闭包可以通过三种方式捕获其环境，他们直接对应函数的三种获取参数的方式：获取所有权，可变借用和不可变借用。这三种捕获值的方式被编码为如下三个 Fn trait：
    - ``FnOnce`` 消费从周围作用域捕获的变量，闭包周围的作用域被称为其 **环境**，environment。为了消费捕获到的变量，闭包必须获取其所有权并在定义闭包时将其移动进闭包。其名称的 ``Once`` 部分代表了闭包不能多次获取相同变量的所有权的事实，所以它只能被调用一次。
    - ``FnMut`` 获取可变的借用值所以可以改变其环境
    - ``Fn`` 从其环境获取不可变的借用值
    - 当创建一个闭包时，Rust 根据其如何使用环境中变量来推断我们希望如何引用环境。由于所有闭包都可以被调用至少一次，所以所有闭包都实现了 ``FnOnce`` 。那些并没有移动被捕获变量的所有权到闭包内的闭包也实现了 ``FnMut`` ，而不需要对被捕获的变量进行可变访问的闭包则也实现了 ``Fn 。
## 13.2 使用迭代器处理元素序列
- 迭代器模式允许你对一个项的序列进行某些处理。**迭代器**（iterator）负责遍历序列中的每一项和决定序列何时结束的逻辑。在 Rust 中，迭代器是 **惰性的**（lazy），这意味着在调用方法使用迭代器之前它都不会有效果。
- 在迭代器上调用 ``next`` 方法改变了迭代器中用来记录序列位置的状态。换句话说，代码 **消费（consume）**了，或使用了迭代器。每一个 ``next`` 调用都会从迭代器中消费一个项。使用 ``for`` 循环时无需使 ``v1_iter`` 可变因为 ``for`` 循环会获取 ``v1_iter`` 的所有权并在后台使 ``v1_iter`` 可变。
- 另外需要注意到从 ``next`` 调用中得到的值是 ``vector`` 的不可变引用。``iter`` 方法生成一个不可变引用的迭代器。如果我们需要一个获取 ``v1`` 所有权并返回拥有所有权的迭代器，则可以调用 ``into_iter`` 而不是 ``iter``。类似的，如果我们希望迭代可变引用，则可以调用 ``iter_mut`` 而不是 ``iter``。
- ``Iterator`` trait 有一系列不同的由标准库提供默认实现的方法这些调用 ``next`` 方法的方法被称为 **消费适配器**（consuming adaptors），因为调用他们会消耗迭代器。例如``sum`` 方法，获取迭代器的所有权并反复调用 ``next`` 来遍历迭代器，因而会消费迭代器。
- Iterator trait 中定义了另一类方法，**迭代器适配器**（iterator adaptors），他们允许我们将当前迭代器变为不同类型的迭代器。可以链式调用多个迭代器适配器。不过因为所有的迭代器都是惰性的，**必须调用一个消费适配器方法以便获取迭代器适配器调用的结果。**
- 实现 ``Iterator trait`` 来创建自定义迭代器
    - **建议直接看例子**
## 13.4 性能对比：循环 VS 迭代器
- 闭包和迭代器是 Rust 受函数式编程语言观念所启发的功能。他们对 Rust 以底层的性能来明确的表达高级概念的能力有很大贡献。闭包和迭代器的实现达到了不影响运行时性能的程度。这正是 Rust 竭力提供零成本抽象的目标的一部分。
## 14.1 采用发布配置自定义构建
- Cargo 有两个主要的配置：运行 ``cargo build`` 时采用的 ``dev`` 配置和运行 ``cargo build --release`` 的 ``release`` 配置。``dev`` 配置被定义为开发时的好的默认配置，release 配置则有着良好的发布构建的默认配置。
## 14.2 将 crate 发布到 Crates.io
- Rust 也有特定的用于文档的注释类型，通常被称为 **文档注释**（documentation comments），他们会生成 HTML 文档。这些 HTML 展示公有 API 文档注释的内容，他们意在让对库感兴趣的程序员理解如何 **使用** 这个 crate，而不是它是如何被实现的。文档注释使用三斜杠 ``///`` 而不是两斜杆以支持 Markdown 注解来格式化文本。文档注释就位于需要文档的项的之前。
- 另一种风格的文档注释，``//!``，这为包含注释的项，而不是注释之后的项增加文档。这通常用于 crate 根文件（通常是 src/lib.rs）或模块的根文件为 crate 或模块整体提供文档。位于项之中的文档注释对于描述 crate 和模块特别有用。使用他们描述其容器整体的目的来帮助 crate 用户理解你的代码组织。
- 文件结构对于用户来说 **不是** 很方便，你也无需重新安排内部组织：你可以选择使用 ``pub use`` 重导出（re-export）项来使公有结构不同于私有结构。重导出获取位于一个位置的公有项并将其公开到另一个位置，好像它就定义在这个新位置一样。
## 14.3 Cargo 工作空间
- 第十二章中，我们构建一个包含二进制 crate 和库 crate 的包。你可能会发现，随着项目开发的深入，库 crate 持续增大，而你希望将其进一步拆分成多个库 crate。对于这种情况，Cargo 提供了一个叫 **工作空间**（workspaces）的功能，它可以帮助我们管理多个相关的协同开发的包。**工作空间** 是一系列共享同样的 Cargo.lock 和输出目录的包。
- 工作空间只在根目录有一个 Cargo.lock，而不是在每一个 crate 目录都有 Cargo.lock。这确保了所有的 crate 都使用完全相同版本的依赖。如果在 Cargo.toml 和 add-one/Cargo.toml 中都增加 ``rand`` crate，则 Cargo 会将其都解析为同一版本并记录到唯一的 Cargo.lock 中。然而，**即使 ``rand`` 被用于工作空间的某处，也不能在其他 crate 中使用它，除非也在他们的 Cargo.toml 中加入 ``rand``。**
- 如果你选择向 crates.io发布工作空间中的 crate，每一个工作空间中的 crate 需要单独发布。``cargo publish`` 命令并没有 ``--all`` 或者 ``-p`` 参数，所以必须进入每一个 crate 的目录并运行 ``cargo publish`` 来发布工作空间中的每一个 crate。
## 15 智能指针
- **指针** （pointer）是一个包含内存地址的变量的通用概念。这个地址引用，或 “指向”（points at）一些其他数据。Rust 中最常见的指针是第四章介绍的 **引用**（reference）。引用以 & 符号为标志并借用了他们所指向的值。除了引用数据没有任何其他特殊功能。它们也没有任何额外开销，所以应用的最多。
- **智能指针**（smart pointers）是一类数据结构，他们的表现类似指针，但是也拥有额外的元数据和功能。在 Rust 中，普通引用和智能指针的一个额外的区别是引用是一类只借用数据的指针；相反，在大部分情况下，智能指针 **拥有** 他们指向的数据。
- 智能指针通常使用结构体实现。智能指针区别于常规结构体的显著特性在于其实现了 ``Deref`` 和 ``Drop`` trait。``Deref`` trait 允许智能指针结构体实例表现的像引用一样，这样就可以编写既用于引用、又用于智能指针的代码。``Drop`` trait 允许我们自定义当智能指针离开作用域时运行的代码。
## 15.1 使用``Box <T>``指向堆上的数据
- 最简单直接的智能指针是 box，其类型是 Box<T>。 box 允许你将一个值放在堆上而不是栈上。留在栈上的则是指向堆数据的指针。
- 除了数据被储存在堆上而不是栈上之外，box 没有性能损失。不过也没有很多额外的功能。它们多用于如下场景：
    - 当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候
        - box允许创建**递归类型**（无法在编译时知道大小的类型，其值的一部分可以是相同类型的另一个值，这种值的嵌套理论上可以无限的进行下去。）
            - const list原型
            ```rust
            enum List {
                Cons(i32, List),
                Nil,
            }
            fn main() {
                let list = Cons(1, Cons(2, Cons(3, Nil)));
            }
            ```
            - Box创建递归类型的实现
            ```rust
            enum List {
                Cons(i32, Box<List>),
                Nil,
            }

            fn main() {
                let list = Cons(1,
                    Box::new(Cons(2,
                        Box::new(Cons(3,
                            Box::new(Nil))))));
            }
            ```
            因为 ``Box<T>`` 是一个指针，我们总是知道它需要多少空间：指针的大小并不会根据其指向的数据量而改变。这意味着可以将 ``Box`` 放入 ``Cons`` 成员中而不是直接存放另一个 ``List`` 值。``Box`` 会指向另一个位于堆上的 ``List`` 值，而不是存放在 ``Cons`` 成员中。从概念上讲，我们仍然有一个通过在其中 “存放” 其他列表创建的列表，**不过现在实现这个概念的方式更像是一个项挨着另一项，而不是一项包含另一项。**
    - 当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候
        - 转移大量数据的所有权可能会花费很长的时间，因为数据在栈上进行了拷贝。为了改善这种情况下的性能，可以通过 ``box`` 将这些数据储存在堆上。接着，只有少量的指针数据在栈上被拷贝。
    - 当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候
        - trait对象
## 15.2 通过 Deref trait 将智能指针当作常规引用处理
- 实现 ``Deref`` trait 允许我们重载 **解引用运算符**（dereference operator）*（与乘法运算符或通配符相区别）。通过这种方式实现 ``Deref`` trait 的智能指针可以被当作常规引用来对待，可以编写操作引用的代码并用于智能指针。
- Rust 将 ``*`` 运算符替换为先调用 ``deref`` 方法再进行普通解引用的操作，如此我们便不用担心是否还需手动调用 ``deref`` 方法了。Rust 的这个特性可以让我们写出行为一致的代码，无论是面对的是常规引用还是实现了 ``Deref`` 的类型。``deref`` 方法返回值的引用，以及 ``*(y.deref())`` 括号外边的普通解引用仍为必须的原因在于所有权。如果 ``deref`` 方法直接返回值而不是值的引用，其值（的所有权）将被移出 ``self``。在这里以及大部分使用解引用运算符的情况下我们并不希望获取 ``MyBox<T>`` 内部值的所有权。
```rust
impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &T {
        &self.0
    }
}
```
- 解引用强制多态（deref coercions）是 Rust 在函数或方法传参上的一种便利。其将实现了 ``Deref`` 的类型的引用转换为原始类型通过 ``Deref`` 所能够转换的类型的引用。
- 类似于如何使用 ``Deref`` trait 重载不可变引用的 * 运算符，Rust 提供了 ``DerefMut`` trait 用于重载可变引用的 * 运算符。Rust 在发现类型和 trait 实现满足三种情况时会进行解引用强制多态：
    - 当 ``T: Deref<Target=U>`` 时从 ``&T`` 到 ``&U``。
    - 当 ``T: DerefMut<Target=U>`` 时从 ``&mut T`` 到 ``&mut U``。
    - 当 ``T: Deref<Target=U>`` 时从 ``&mut T`` 到 ``&U``。
## 15.3 使用 Drop Trait 运行清理代码
- 指定在值离开作用域时应该执行的代码的方式是实现 ``Drop`` trait。``Drop`` trait 要求实现一个叫做 ``drop`` 的方法，它获取一个 ``self`` 的可变引用。
- 通过 ``std::mem::drop`` 提早丢弃值
    - Rust 不允许我们显式调用 ``drop`` 因为 Rust 仍然会在 ``main`` 的结尾对值自动调用 ``drop``，这会导致一个 **double free** 错误，因为 Rust 会尝试清理相同的值两次。
## 15.4 Rc<T> 引用计数智能指针
- 为了启用多所有权，Rust 有一个叫做 ``Rc<T>`` 的类型。其名称为 **引用计数**（reference counting）的缩写。引用计数意味着记录一个值引用的数量来知晓这个值是否仍在被使用。如果某个值有零个引用，就代表没有任何有效引用并可以被清理。(``Rc<T>`` 只能用于单线程场景)
- ``Rc::clone`` 的实现并不像大部分类型的 ``clone`` 实现那样对所有数据进行深拷贝。``Rc::clone`` 只会增加引用计数，这并不会花费多少时间。深拷贝可能会花费很长时间。通过使用 ``Rc::clone`` 进行引用计数，可以明显的区别深拷贝类的克隆和增加引用计数类的克隆。
## 15.5 RefCell<T> 和内部可变性模式
- **内部可变性**（Interior mutability）是 Rust 中的一个设计模式，它允许你即使在有不可变引用时也可以改变数据，这通常是借用规则所不允许的。为了改变数据，该模式在数据结构中使用 ``unsafe`` 代码来模糊 Rust 通常的可变性和借用规则。
- 对于引用和 ``Box<T>``，借用规则的不可变性作用于编译时。对于 ``RefCell<T>``，这些不可变性作用于 **运行时**。对于引用，如果违反这些规则，会得到一个编译错误。而对于 ``RefCell<T>``，如果违反这些规则程序会 panic 并退出。
- 如下为选择 ``Box<T>``，``Rc<T>`` 或 ``RefCell<T>`` 的理由：
    - ``Rc<T>`` 允许相同数据有多个所有者；``Box<T>`` 和 ``RefCell<T>`` 有单一所有者。
    - ``Box<T>`` 允许在编译时执行不可变或可变借用检查；``Rc<T>``仅允许在编译时执行不可变借用检查；``RefCell<T>`` 允许在运行时执行不可变或可变借用检查。
    - 因为 ``RefCell<T>`` 允许在运行时执行可变借用检查，所以我们可以在即便 ``RefCell<T>`` 自身是不可变的情况下修改其内部的值。
- 当创建不可变和可变引用时，我们分别使用 ``&`` 和 ``&mut`` 语法。对于 ``RefCell<T>`` 来说，则是 ``borrow`` 和 ``borrow_mut`` 方法，这属于 ``RefCell<T>`` 安全 API 的一部分。
- 结合 ``Rc<T>`` 和 ``RefCell<T>`` 来拥有多个可变数据所有者
## 15.6 引用循环与内存泄漏
- Rust 的内存安全性保证使其难以意外地制造永远也不会被清理的内存（被称为 **内存泄漏**（memory leak）），但并不是不可能。与在编译时拒绝数据竞争不同， Rust 并不保证完全地避免内存泄漏，这意味着内存泄漏在 Rust 被认为是内存安全的。
- ``weak_count`` 无需计数为 0 就能使 ``Rc<T>`` 实例被清理。
- 强引用代表如何共享 ``Rc<T>`` 实例的所有权，但弱引用并不属于所有权关系。他们不会造成引用循环，因为任何弱引用的循环会在其相关的强引用计数为 0 时被打断。
- 因为 ``Weak<T>`` 引用的值可能已经被丢弃了，为了使用 ``Weak<T>`` 所指向的值，我们必须确保其值仍然有效。为此可以调用 ``Weak<T>`` 实例的 ``upgrade`` 方法，这会返回 ``Option<Rc<T>>``。
- 父节点应该拥有其子节点：如果父节点被丢弃了，其子节点也应该被丢弃。然而子节点不应该拥有其父节点：如果丢弃子节点，其父节点应该依然存在。**这正是弱引用的例子!**